''' 느낀점 및 생각할 점
너무 간단한 문제였는데 오히려 이렇게 간단히 풀리지 않을 것이라고 생각하여 규칙을 계속해서 찾았다.
예시들을 적어보니 결국엔 아래와 같이 정리되었다.
1. 선택할 수 있는 수가 총 종류의 수보다 크거나 같을 때는 종류의 수를 return
2. 선택할 수 있는 수가 총 종류의 수보다 작을 때는 선택할 수 있는 수를 return
문제에서 주어지는 모든 case가 위 두 가지를 벗어날 수 없음을 너무 늦게 알아차렸다.
다음에는 꼭 제출을 먼저 해봐서 시간을 절약하자. 물론 실제상황에서는 히든케이스에 대한 정답여부를 알 수 없으니 결국 빨리 찾아내는 수 밖에 없긴 하다.
'''


# 가장 많은 종류의 포켓몬을 선택했을 때 종류의 개수 출력
# from itertools import combinations_with_replacement # 완전탐색
# 만약 len(nums)/2가 종류의수 len(set(nums))보다 크거나 같다면 len(set(nums))를 return
# 만약 len(nums)/2가 종류의수 len(set(nums))보다 작다면? 

def solution(nums):
    n = int(len(nums) / 2) # 2/n 마리를 선택해야 함
    max_num_species = len(set(nums))
    if n >= max_num_species:
        return max_num_species
    else:
        return n

'''
0 0 0 0
1
0 0 0 1
2
3 1 2 3
1 2 3 3
1 1 2 3
2 2 2 1


1 2 3 4 => 4개뽑기 (뽑는 수가 같거나 더 많아) => 종류 수
1 2 3 4 => 4개뽑을 수 있음
0 0 0 0 => 2개뽑기 (뽑는수가 같거나 더 많아) => 종류 수
0 => 1개만 뽑을 수 있음
1 2 3 4 => 2개 뽑기 (뽑는 수가 더 적어) => 뽑는 수
1 2 => 2개만 뽑을 수 있음

n 개를 무조건 뽑아야 되니까

'''
