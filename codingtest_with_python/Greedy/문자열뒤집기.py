# condingtest_with_python_part3_Greedy
# 문자열뒤집기.py



# 나의 풀이 (교재 해설 참고)

## 그냥 전부 0으로 바꾸는 경우와 전부 1로 바꾸는 경우 중 더 작은 횟수를 가지는 경우를 계산하면 됨!
## 내가 생각못했던 핵심 : 숫자가 바뀌는지 안바뀌는 지는 하나씩 읽어들이며 현재 숫자와 그다음 숫자가 같냐 다르냐로 구분 할 수 있음
s = input()

countzero = 0 # 전부 0으로 바꾸는 경우 뒤집기 횟수
countone = 0 # 전부 1로 바꾸는 경우 뒤집기 횟수

# 첫 번째 원소에 대해서 처리
if s[0] == 0:
    countone += 1
else:
    countzero += 1

for i in range(len(s) - 1): # 그다음 숫자까지 고려할거여서 1 빼줌
    if s[i] != s[i + 1]:
        # 다음 수에서 1로 바뀌는 경우
        if s[i + 1] == '1':
            countzero += 1
        # 다음 수에서 0으로 바뀌는 경우
        else:
            countone += 1
## 전부 0으로 바꾸는 경우와 전부 1로 바꾸는 경우 중 더 작은 횟수를 가지는 경우를 출력
print(min(countzero, countone))

        




# 나의 풀이 (주어진 풀이 시간 : 20분, 풀이 시간 : 23분 15.51초)

## 최소 횟수로 뒤집어서 같은 숫자로만 되게 만들기
## 뒤집기는 10001 -> 01110 (즉 뒤집기는 1을 0으로, 0을 1로 바꾸는 것)
## ex 0001100 -> 1111111 or 0000000 으로 만들어야됨
## 뒤집기는 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 거임
"""
S = input()
count = 0

## 0과 1중 개수가 더 작은 걸 선택하여 그것들의 덩어리들을 뒤집는게 낫지 않을까?
d = ''
zero_number = S.count('0')
print(f'zero_number : {zero_number}')
one_number = S.count('1')
print(f'one_number : {one_number}')
if zero_number <= one_number:
    d = '0'
else:
    d = '1'
print(f'd : {d}')
cnt = 0
for n in S:
    if n == d:
        cnt += 1
        if cnt == 2:
            count += 1
            cnt = 0

print(count)
            

"""

# 느낀점
"""
문제를 처음 딱 봤을 때, 단순해 보였지만 내가 생각한 greedy 해법이 맞는지 몰라서
일단 시도해보려고 했다. 하지만 그 해법도 구현하기 쉽다고 생각하였는데 빠르게 구현하지 못했고,
실수가 나와서 그것을 찾는데 시간이 오래걸렸다. 그리고 변수이름도 하나도 신경쓰지 못했다.
이전까지 문제의 원인들을 print로 출력해가며 찾아냈지만 프로그래머스 코테에서 그렇게 확인하지 못하므로
할 수 없었다.
해설을 보고 해설이 더 안전한 풀이라고 생각했다. 2가지 경우밖에 존재하지 않으니 두 개다 계산하고
그 중 작은 값을 선택하면 되는 간단한 문제였다.
내가 떠올린 아이디어는 분명히 반례가 존재할 수 있을 수도 있을 것이다.
"""
