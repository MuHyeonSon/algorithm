# condingtest_with_python_part3_Greedy
# 모험가길드.py



# 나의 풀이 (교재 해설 참고)



# 나의 풀이 (주어진 풀이 시간 : 30분, 풀이 시간 : 17분 54.48초)

## 그룹수의 값을 최대로 만들어야됨
## 한그룹에는 x가 반드시 x개 있어야됨 , 사람들 전부를 그룹에 포함시킬 필요는 없음
## 계수 정렬 아이디어를 이용??
## 만들 수 있는 애들은 다 만들어야됨, 
## 따라서 
## 1. 오름차순으로 정렬하고, 
## 2. set 같은 자료구조에 집어 넣어서 중복 값 없이 만들고 어떤 원소들이 있는지 알아내자 리스트 복사시 딥카피 이용
## 3. 어떤 원소들이 있는 지 알아냈으면 그 원소들이 각각 입력받은 리스트에 몇개가 존재하는지 체크
## 4. 원소보다 그 원소의 개수가 더 적다면 -> 못 만듬
## 5. 원소보다 그 원소의 개수가 크다면 -> 원소의 개수를 원소로 나누어서 정수나누기 값만큼, 즉, 몫 만큼 그룹을 만들 수 있음
## 근데 set말고 한 번에 딕셔너리 형식으로 각 개수 카운트 해주는 함수 있던 걸로 기억하는데..
"""
import copy

N = int(input()) # 모험가의 수 입력받음
scary = list(map(int,input().split())) # 각 모험가의 공포도를 입력받음
scary.sort() # 모험가들의 공포도를 오름차순으로 정렬

count_list = copy.deepcopy(scary)
data = set(count_list)
result = 0



for n in data:
    number_of_n = scary.count(n)
    if number_of_n >= n:
        result += number_of_n // n

print(result)


"""


# 교재 풀이
n = int(input())
data = list(map(int, input().split())) 
data.sort()

result = 0 # 총 그룹의 수
count = 0 # 현재 그룹에 포험된 모험가의 수

for i in data: # 공포도를 낮은 것부터 하나씩 확인하며
    count += 1 # 현재 그룹에 해당 모험가를 포함시키기
    if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
        result += 1 # 총 그룹의 수 증가시키기
        count = 0 #현재 그룹에 포함된 모험가의 수 초기화
        
print(result) # 총 그룹의 수 출력



# 느낀점
"""
입력예시는 맞았지만 해설을 듣고 나의 풀이가 잘못되었다는 것을 알게 됐다.
문제를 잘못 이해했다.

- 반드시 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 된다는 것을
-> 이 문장을 그룹은 X인 모험가들로만 구성되어야 되는 것으로 이해했다.
-> 하지만 꼭 X인 모험가들로 구성하지 않아도 된다는 것을 반례를 확인해보니 알게 됐다.

ex) 1, 2, 3, 3
내가 구현한 대로라면 저 입력이 들어왔을 때 만들어지는 최대 그룹수는 1이다.
하지만 (1) , (2,3,3) 이렇게 구성되도 문제가 없다.
두 번째 그룹의 경우 공포도가 2인 모험가에 대해서도 그룹 인원이 3명으로 2명이상이니 괜찮고
                    공포도가 3인 모험가에 대해서도 그룹 인원이 3명으로 3명 이상이니
문제에서 주어진 조건이 성립하는 것이었다.
그래서 교재의 풀이가 가장 간단하고 깔끔하고 간단하다는 것을 느꼈다.

항상 이러한 부분을 똑바로 신경써야 겠다고 생각했다.
"""
