# 문자열 뒤집기
# 문자열 S에 있는 모든 숫자를 전부 같게 만들어야됨
# 최소의 횟수로
# 할 수 있는 것 : S내의 연속된 하나 이상의 숫자를 잡고 모두 뒤집는다 (1은 0으로 0은 1로)
# len(s) < 100만

# 단순히 개수를 가지고 판단하는 것은 안됨 흩어져있는데 더 작을 수 있잖아
# 덩어리가 몇개인지 판단? 그 알고리즘이 더 복잡할 수 있을 거같음
# 0을 바꾸는 경우와 1을 바꾸는 경우 중 더 작은 걸로 선택하면 될까?

# 0001100

s = input()
zero = 0  # 전부 0으로 바꾸는 경우의 횟수
one = 0  # 전부 1로 바꾸는 경우의 횟수

if s[0] == "1":
    zero += 10
else:
    one += 1

for i in range(len(s) - 1):
    if s[i] != s[i + 1]:
        if s[i] == "1":
            one += 1
        else:
            zero += 1

print(min(zero, one))


## 제한시간 20분, 풀이시간 분 => 시간 내에 못품
"""
거의 비슷하게 아이디어를 떠올렸으나 끝까지 구현하지 못함
0인 경우와 1인경우를 나누어 횟수를 계산하고 그중 더 적은 횟수를 출력한다는 아이디어까지는 잘 떠올렸다
하지만 0으로 바꾸는 경우가 모두 0으로 만든다는 것과 같다는 의미를 잘 파악했다면 잘 풀 수 있었을 것 같다.

가장 생각해 내기 어려웠던 점은 첫번째 문자에 대한 처리와 0,1 각각에 대한 뒤집기 횟수 계산이다

첫번째 문자가 0인 경우 모두 1로 만드는 방법의 횟수는 1증가 시켜야되고 첫번쨰 문자가 1인 경우 모두 0으로 만드는 방법의 횟수를
1 증가시켜야 한다는 것.

현재 문자와 다음문자가 서로 다름을 판별함으로써 뒤집는 횟수를 계산해야된다는 점과 반복문 시작점이 인덱스 1이 아닌 0시점이라는 것
실제 시뮬레이션을 머릿속에서 해보지 않으면 쉽게 떠올리지 못할 것 같다.
이 문제 꼭 다시 풀자!
"""
