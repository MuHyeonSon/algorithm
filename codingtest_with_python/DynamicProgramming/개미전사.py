# condingtest_with_python_part2_다이나믹_프로그래밍
# 개미전사.py

# 나의 풀이 (교재해설참고)

## 식량 창고의 개수 입력 받기
N = int(input()) # (3 <= N <= 100)
## 모든 식량 정보 입력받기
K = list(map(int, input().split())) # (0 <= K <= 1000)
K.insert(0,0) # 인덱스가 아니라 번호로 접근하기 위해 (1부터 세기 위해)

## 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 
DP_Table = [0] * 101

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
DP_Table[1] = K[1]
DP_Table[2] = K[2]
for i in range(3, N + 1):
  DP_Table[i] = max(DP_Table[i - 1], DP_Table[i - 2] + K[i]) ## 현재 위치에서의, 최댓값 선택(i - 1 번째 식량을 터는게 클지, i-1 털지 말고,그 전인 i - 2번째 식량 털고 이번 식량 털지 두 경우 중 더 큰 경우를 선택 하여 기록)

#계산된 결과 출력   
print(DP_Table[N])

# 나의 풀이 (최종)

# 교재 풀이

  

# 느낀점
"""
이번에는 문제도 잘 이해가 되었고, 해결할 수 있을 거라고 생각했지만
역시나 풀이시간 내에 해결하지 못했다. 다른 문제들과 달랐던 점은 한 칸 이상 떨어진 곳만 약탈 할 수 있다는 점이었다.
이것을 고려했을 때 어떤 점화식을 만들 수 있는지 생각하기 어려웠고, n이 3인 경우부터 하나씩 증가하며 여러 경우들을생각하며
작은 문제의 해들을 가지고 어떻게 큰 문제의 해를 구할 수 있을지 떠올려보았지만 정확한 아이디어를 생각해내지 못했다.
해설을 보면 그림으로 도식화 한 뒤에 생각하면 어렵지 않다고 하지만, 실제 코테에서 메모를 할 수 있는 곳이
많지 않은 것으로 알고있다. 주석으로 최대한 그림을 표현해보는 수 밖에 없을 것 같다.
내가 생각한 것들 중 같은 해설과 같은 아이디어가 있었지만 이 아이디어가 적용이 가능한지에 대한
해설과 소스코드를 보았을 때, 허무함이 느껴졌다. 분명 내가 생각한 것과 유사한데, 실제로 코드를 구현해내지 못했다는 것이다.
검증 과정을 제대로 하지 않았고, 그렇게 만약 했더라도 시간도 오래걸렸고, 코드로 에러가 발생하지 않게 풀이시간 내에 구현할 수 없었을 것이다.
그냥 계속해서 반복하는 수밖에 없다고 생각한다. 익숙해질 때까지 계속 연습할 것이다. 
"""
